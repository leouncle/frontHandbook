<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" type="image/png" sizes="16x16" href="/frontHandbook/images/icons/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/frontHandbook/images/icons/favicon-32x32.png"><link rel="manifest" href="/frontHandbook/manifest.webmanifest"><meta name="application-name" content="frontHandbook"><meta name="apple-mobile-web-app-title" content="frontHandbook"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/frontHandbook/images/icons/apple-touch-icon.png"><link rel="mask-icon" href="/frontHandbook/images/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileColor" content="#3eaf7c"><meta name="theme-color" content="#3eaf7c"><title>React | 前端项目手册</title><meta name="description" content="leouncle's front handbook">
    <link rel="modulepreload" href="/frontHandbook/assets/app.1d2f7275.js"><link rel="modulepreload" href="/frontHandbook/assets/react.html.f472e972.js"><link rel="modulepreload" href="/frontHandbook/assets/react.html.71d5a80f.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.25c25981.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.558aae2e.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar1.html.4ce5a027.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar2.html.dd44d8d9.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar3.html.51dbe4ec.js"><link rel="prefetch" href="/frontHandbook/assets/earlyComplete.html.9569c449.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.e30d2014.js"><link rel="prefetch" href="/frontHandbook/assets/business.html.f4c7bcec.js"><link rel="prefetch" href="/frontHandbook/assets/git.html.699bd6a3.js"><link rel="prefetch" href="/frontHandbook/assets/work.html.2ff15753.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.f3c755e3.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar.html.9f4daa80.js"><link rel="prefetch" href="/frontHandbook/assets/floodEra.html.1800b488.js"><link rel="prefetch" href="/frontHandbook/assets/jQuery.html.02acaae9.js"><link rel="prefetch" href="/frontHandbook/assets/jsEcology.html.3d3cb23c.js"><link rel="prefetch" href="/frontHandbook/assets/nodejs_jquery.html.0c2945da.js"><link rel="prefetch" href="/frontHandbook/assets/prototype.html.3b914561.js"><link rel="prefetch" href="/frontHandbook/assets/vue_react_angular.html.7a2cacfd.js"><link rel="prefetch" href="/frontHandbook/assets/vuejs.html.102ded1d.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.ae455567.js"><link rel="prefetch" href="/frontHandbook/assets/css.html.ed4c1205.js"><link rel="prefetch" href="/frontHandbook/assets/engineering.html.aadc35f2.js"><link rel="prefetch" href="/frontHandbook/assets/html.html.0bf41103.js"><link rel="prefetch" href="/frontHandbook/assets/http.html.be3f4250.js"><link rel="prefetch" href="/frontHandbook/assets/js.html.252d7db0.js"><link rel="prefetch" href="/frontHandbook/assets/vue2.html.80542629.js"><link rel="prefetch" href="/frontHandbook/assets/vue3.html.d1bcdca0.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.28f829b3.js"><link rel="prefetch" href="/frontHandbook/assets/components.html.5d1a0234.js"><link rel="prefetch" href="/frontHandbook/assets/compositionApi.html.a9445a8f.js"><link rel="prefetch" href="/frontHandbook/assets/env.html.bc4b99fd.js"><link rel="prefetch" href="/frontHandbook/assets/mockApi.html.ca2f0cf4.js"><link rel="prefetch" href="/frontHandbook/assets/style.html.e446e6c0.js"><link rel="prefetch" href="/frontHandbook/assets/countTo.html.57b9a7eb.js"><link rel="prefetch" href="/frontHandbook/assets/dragable.html.c1818abf.js"><link rel="prefetch" href="/frontHandbook/assets/echarts.html.41f5792a.js"><link rel="prefetch" href="/frontHandbook/assets/filter_directive.html.ead8eb04.js"><link rel="prefetch" href="/frontHandbook/assets/formTable.html.46f8a6f8.js"><link rel="prefetch" href="/frontHandbook/assets/svgIcon.html.b9accc6f.js"><link rel="prefetch" href="/frontHandbook/assets/404.html.93146c89.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.f3b5e979.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.ca76fd3f.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar1.html.c229d26e.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar2.html.17d358b5.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar3.html.c473f992.js"><link rel="prefetch" href="/frontHandbook/assets/earlyComplete.html.09fb85d5.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.e3da51c3.js"><link rel="prefetch" href="/frontHandbook/assets/business.html.55f794cd.js"><link rel="prefetch" href="/frontHandbook/assets/git.html.07bb25d4.js"><link rel="prefetch" href="/frontHandbook/assets/work.html.04b03d71.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.209a7a05.js"><link rel="prefetch" href="/frontHandbook/assets/browserWar.html.db261bda.js"><link rel="prefetch" href="/frontHandbook/assets/floodEra.html.53ca574b.js"><link rel="prefetch" href="/frontHandbook/assets/jQuery.html.35584baf.js"><link rel="prefetch" href="/frontHandbook/assets/jsEcology.html.54a07857.js"><link rel="prefetch" href="/frontHandbook/assets/nodejs_jquery.html.32161b2c.js"><link rel="prefetch" href="/frontHandbook/assets/prototype.html.543e95f7.js"><link rel="prefetch" href="/frontHandbook/assets/vue_react_angular.html.61a22e31.js"><link rel="prefetch" href="/frontHandbook/assets/vuejs.html.7fa198b2.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.08d684af.js"><link rel="prefetch" href="/frontHandbook/assets/css.html.919f6941.js"><link rel="prefetch" href="/frontHandbook/assets/engineering.html.74a5bb8e.js"><link rel="prefetch" href="/frontHandbook/assets/html.html.0a8ee3d2.js"><link rel="prefetch" href="/frontHandbook/assets/http.html.65b49bf4.js"><link rel="prefetch" href="/frontHandbook/assets/js.html.34253ba1.js"><link rel="prefetch" href="/frontHandbook/assets/vue2.html.fa02c816.js"><link rel="prefetch" href="/frontHandbook/assets/vue3.html.0267c03c.js"><link rel="prefetch" href="/frontHandbook/assets/index.html.0d0390f7.js"><link rel="prefetch" href="/frontHandbook/assets/components.html.a74189cf.js"><link rel="prefetch" href="/frontHandbook/assets/compositionApi.html.1a624f71.js"><link rel="prefetch" href="/frontHandbook/assets/env.html.45ac9e6f.js"><link rel="prefetch" href="/frontHandbook/assets/mockApi.html.de75fa13.js"><link rel="prefetch" href="/frontHandbook/assets/style.html.975c0a80.js"><link rel="prefetch" href="/frontHandbook/assets/countTo.html.14e22fa4.js"><link rel="prefetch" href="/frontHandbook/assets/dragable.html.8ceba16b.js"><link rel="prefetch" href="/frontHandbook/assets/echarts.html.37ddf83e.js"><link rel="prefetch" href="/frontHandbook/assets/filter_directive.html.ad4069d5.js"><link rel="prefetch" href="/frontHandbook/assets/formTable.html.1550a155.js"><link rel="prefetch" href="/frontHandbook/assets/svgIcon.html.ecaef612.js"><link rel="prefetch" href="/frontHandbook/assets/404.html.2df48d51.js"><link rel="prefetch" href="/frontHandbook/assets/404.319be1b9.js"><link rel="prefetch" href="/frontHandbook/assets/Layout.49035b2e.js">
    <link rel="stylesheet" href="/frontHandbook/assets/style.84478f0b.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/frontHandbook/" class=""><img class="logo" src="/frontHandbook/images/logo.png" alt="前端项目手册"><span class="site-name can-hide">前端项目手册</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/frontHandbook/projectIntro/" class="" aria-label="项目介绍"><!--[--><!--]--> 项目介绍 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/devDoc/" class="" aria-label="开发文档"><!--[--><!--]--> 开发文档 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/frontHistory/" class="" aria-label="前端简史"><!--[--><!--]--> 前端简史 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/browserHistory/" class="" aria-label="浏览器发展史"><!--[--><!--]--> 浏览器发展史 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/interview/" class="router-link-active" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/leouncle/frontHandbook" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索文档" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/frontHandbook/projectIntro/" class="" aria-label="项目介绍"><!--[--><!--]--> 项目介绍 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/devDoc/" class="" aria-label="开发文档"><!--[--><!--]--> 开发文档 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/frontHistory/" class="" aria-label="前端简史"><!--[--><!--]--> 前端简史 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/browserHistory/" class="" aria-label="浏览器发展史"><!--[--><!--]--> 浏览器发展史 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontHandbook/interview/" class="router-link-active" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/leouncle/frontHandbook" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">面试题 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontHandbook/interview/" class="router-link-active sidebar-item" aria-label="/interview/README.md"><!--[--><!--]--> /interview/README.md <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/html.html" class="sidebar-item" aria-label="html"><!--[--><!--]--> html <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/css.html" class="sidebar-item" aria-label="css"><!--[--><!--]--> css <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/js.html" class="sidebar-item" aria-label="js"><!--[--><!--]--> js <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/vue2.html" class="sidebar-item" aria-label="Vue2"><!--[--><!--]--> Vue2 <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/vue3.html" class="sidebar-item" aria-label="/interview/vue3.md"><!--[--><!--]--> /interview/vue3.md <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontHandbook/interview/react.html#_1-fiber" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. Fiber"><!--[--><!--]--> 1. Fiber <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_2-生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 生命周期"><!--[--><!--]--> 2. 生命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_3-setstate" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. setState"><!--[--><!--]--> 3. setState <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_4-hoc-高阶组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. HOC(高阶组件)"><!--[--><!--]--> 4. HOC(高阶组件) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_5-redux" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. Redux"><!--[--><!--]--> 5. Redux <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_6-react-hooks" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. React Hooks"><!--[--><!--]--> 6. React Hooks <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_7-ssr" class="router-link-active router-link-exact-active sidebar-item" aria-label="7. SSR"><!--[--><!--]--> 7. SSR <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontHandbook/interview/react.html#_8-函数式编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="8. 函数式编程"><!--[--><!--]--> 8. 函数式编程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/frontHandbook/interview/http.html" class="sidebar-item" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a><!----></li><li><a href="/frontHandbook/interview/engineering.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1><p>React 也是现如今最流行的前端框架，也是很多大厂面试必备。React 与 Vue 虽有不同，但同样作为一款 UI 框架，虽然实现可能不一样，但在一些理念上还是有相似的，例如数据驱动、组件化、虚拟 dom 等。这里就主要列举一些 React 中独有的概念。</p><h2 id="_1-fiber" tabindex="-1"><a class="header-anchor" href="#_1-fiber" aria-hidden="true">#</a> 1. Fiber</h2><p>React 的核心流程可以分为两个部分:</p><ul><li>reconciliation ( <strong>调度算法</strong> ，也可称为 render): <ul><li>更新 state 与 props；</li><li>调用生命周期钩子；</li><li>生成 virtual dom； <ul><li>这里应该称为 Fiber Tree 更为符合；</li></ul></li><li>通过新旧 vdom 进行 diff 算法，获取 vdom change；</li><li>确定是否需要重新渲染</li></ul></li><li>commit: <ul><li>如需要，则操作 dom 节点更新；</li></ul></li></ul><p>要了解 Fiber，我们首先来看为什么需要它？</p><ul><li><strong>问题</strong> : 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 <strong>同步阻塞</strong> 。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 <strong>同步递归</strong> 的方式进行遍历渲染，而这个过程最大的问题就是无法 <strong>暂停和恢复</strong> 。</li><li><strong>解决方案</strong> : 解决同步阻塞的方法，通常有两种: <strong>异步</strong> 与 <strong>任务分割</strong> 。而 React Fiber 便是为了实现任务分割而诞生的。</li><li><strong>简述</strong> :</li><li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 <strong>单链表树遍历算法</strong> 。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。</li><li>这里我理解为是一种 <strong>任务分割调度算法</strong> ，主要是 将原先同步更新渲染的任务分割成一个个独立的 <strong>小任务单位</strong> ，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</li><li><strong>核心</strong> :</li><li>Fiber 这里可以具象为一个 <strong>数据结构</strong> :</li></ul><div class="language-kotlin ext-kt line-numbers-mode"><pre class="language-kotlin"><code>  <span class="token keyword">class</span> Fiber <span class="token punctuation">{</span>
  	<span class="token keyword">constructor</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		<span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
  		<span class="token comment">// 指向第一个 child 节点</span>
  		<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
  		<span class="token comment">// 指向父节点</span>
  		<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> parent
  		<span class="token comment">// 指向第一个兄弟节点</span>
  		<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
  	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>链表树遍历算法</strong> : 通过 <strong>节点保存与映射</strong> ，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提； <ul><li>1、首先通过不断遍历子节点，到树末尾；</li><li>2、开始通过 sibling 遍历兄弟节点；</li><li>3、return 返回父节点，继续执行 2；</li><li>4、直到 root 节点后，跳出遍历；</li></ul></li><li><strong>任务分割</strong> ，React 中的渲染更新可以分成两个阶段: <ul><li><strong>reconciliation 阶段</strong> : vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。</li><li><strong>Commit 阶段</strong> : 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。</li></ul></li><li><strong>分散执行</strong> : 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新 API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code><ul><li>低优先级的任务交给 <code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；</li><li>高优先级的任务交给 <code>requestAnimationFrame</code>处理；</li></ul></li></ul><div class="language-reasonml ext-reasonml line-numbers-mode"><pre class="language-reasonml"><code>  // 类似于这样的方式
  requestIdleCallback((deadline) =&gt; {
      // 当有空闲时间时，我们执行一个组件渲染；
      // 把任务塞到一个个碎片时间中去；
      while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; nextComponent) {
          nextComponent = performWork(nextComponent);
      }
  });
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优先级策略</strong> : 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul><blockquote><p><strong>Tips</strong> :</p><p>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</p><p>当遇到进程阻塞的问题时， <strong>任务分割</strong> 、<strong>异步调用</strong> 和 <strong>缓存策略</strong> 是三个显著的解决思路。</p><p><strong>感谢 @Pengyuan 童鞋，在评论中指出了几个 Fiber 中最核心的理念，感恩！！</strong></p></blockquote><h2 id="_2-生命周期" tabindex="-1"><a class="header-anchor" href="#_2-生命周期" aria-hidden="true">#</a> 2. 生命周期</h2><p>在新版本中，React 官方对生命周期有了新的 <strong>变动建议</strong> :</p><ul><li>使用 <code>getDerivedStateFromProps</code> 替换 <code>componentWillMount</code> 与 <code>componentWillReceiveProps</code>；</li><li>使用 <code>getSnapshotBeforeUpdate</code>替换 <code>componentWillUpdate</code>；</li><li>避免使用 <code>componentWillReceiveProps</code>；</li></ul><p>其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:</p><ul><li><strong>reconciliation</strong> :</li><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><strong>commit</strong> :</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul><p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 <strong>多次调用</strong> 的情况，产生一些意外错误。</p><p>新版的建议生命周期如下:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 替换 `componentWillReceiveProps` ，</span>
  <span class="token comment">// 初始化和 update 时被调用</span>
  <span class="token comment">// 静态函数，无法使用 this</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 判断是否需要更新组件</span>
  <span class="token comment">// 可以用于组件性能优化</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件被挂载后触发</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 替换 componentWillUpdate</span>
  <span class="token comment">// 可以在更新之前获取最新 dom 数据</span>
  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件更新后调用</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件即将销毁</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件已销毁</span>
  <span class="token function">componentDidUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>使用建议</strong> :</li><li>在 <code>constructor</code>初始化 state；</li><li>在 <code>componentDidMount</code>中进行事件监听，并在 <code>componentWillUnmount</code>中解绑事件；</li><li>在 <code>componentDidMount</code>中进行数据的请求，而不是在 <code>componentWillMount</code>；</li><li>需要根据 props 更新 state 时，使用 <code>getDerivedStateFromProps(nextProps, prevState)</code>； <ul><li>旧 props 需要自己存储，以便比较；</li></ul></li></ul><div class="language-kotlin ext-kt line-numbers-mode"><pre class="language-kotlin"><code>  <span class="token keyword">public</span> static <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 当新 props 中的 data 发生变化时，同步更新到 state 上</span>
  	<span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>data <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		<span class="token keyword">return</span> <span class="token punctuation">{</span>
  			<span class="token keyword">data</span><span class="token operator">:</span> nextProps<span class="token punctuation">.</span>data
  		<span class="token punctuation">}</span>
  	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  		<span class="token keyword">return</span> null1
  	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以在 <code>componentDidUpdate</code>监听 props 或者 state 的变化，例如:</li></ul><div class="language-kotlin ext-kt line-numbers-mode"><pre class="language-kotlin"><code>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 当 id 发生变化时，重新获取数据</span>
  	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id <span class="token operator">!==</span> prevProps<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在 <code>componentDidUpdate</code>使用 <code>setState</code>时，必须加条件，否则将进入死循环；</li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；</li><li><code>shouldComponentUpdate</code>: 默认每次调用 <code>setState</code>，一定会最终走到 diff 阶段，但可以通过 <code>shouldComponentUpdate</code>的生命钩子返回 <code>false</code>来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li></ul><h2 id="_3-setstate" tabindex="-1"><a class="header-anchor" href="#_3-setstate" aria-hidden="true">#</a> 3. setState</h2><p>在了解 <code>setState</code>之前，我们先来简单了解下 React 一个包装结构: <strong>Transaction</strong> :</p><ul><li><strong>事务</strong> (Transaction): <ul><li>是 React 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong> 。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0cb48cd4013~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><ul><li><code>setState</code>: React 中用于修改状态，更新视图。它具有以下特点:</li><li><strong>异步与同步</strong> : <code>setState</code>并不是单纯的异步或同步，这其实与调用时的环境相关:</li><li>在 <strong>合成事件</strong> 和 <strong>生命周期钩子(除 componentDidUpdate)</strong> 中，<code>setState</code>是&quot;异步&quot;的； <ul><li><strong>原因</strong> : 因为在 <code>setState</code>的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入 <code>dirtyComponents</code>队列中等待执行；否则，开始执行 <code>batchedUpdates</code>队列更新；</li><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而 <code>componentDidUpdate</code>是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li><li>在合成事件中，React 是基于 <strong>事务流完成的事件委托机制</strong> 实现，也是处于事务流中；</li><li><strong>问题</strong> : 无法在 <code>setState</code>后马上从 <code>this.state</code>上获取更新后的值。</li><li><strong>解决</strong> : 如果需要马上同步去获取新值，<code>setState</code>其实是可以传入第二个参数的。<code>setState(updater, callback)</code>，在回调中即可获取最新值；</li></ul></li><li>在 <strong>原生事件</strong> 和 <strong>setTimeout</strong> 中，<code>setState</code>是同步的，可以马上获取更新后的值； <ul><li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 <code>setTimeout</code>是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li><li><strong>批量更新</strong> : 在 <strong>合成事件</strong> 和 <strong>生命周期钩子</strong> 中，<code>setState</code>更新队列时，存储的是 <strong>合并状态</strong> (<code>Object.assign</code>)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</li><li><strong>函数式</strong> : 由于 Fiber 及 合并 的问题，官方推荐可以传入 <strong>函数</strong> 的形式。<code>setState(fn)</code>，在 <code>fn</code>中返回新的 <code>state</code>对象即可，例如 <code>this.setState((state, props) =&gt; newState)；</code></li><li>使用函数式，可以用于避免 <code>setState</code>的批量更新的逻辑，传入的函数将会被 <strong>顺序调用</strong> ；</li><li><strong>注意事项</strong> :</li><li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li><li>当组件已被销毁，如果再次调用 <code>setState</code>，React 会报错警告，通常有两种解决办法: <ul><li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li><li>在组件内部维护一个状态量 (isUnmounted)，<code>componentWillUnmount</code>中标记为 true，在 <code>setState</code>前进行判断；</li></ul></li></ul><h2 id="_4-hoc-高阶组件" tabindex="-1"><a class="header-anchor" href="#_4-hoc-高阶组件" aria-hidden="true">#</a> 4. HOC(高阶组件)</h2><p>HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。</p><ul><li><p><strong>简述</strong> :</p></li><li><p>高阶组件不是组件，是 <strong>增强函数</strong> ，可以输入一个元组件，返回出一个新的增强组件；</p></li><li><p>高阶组件的主要作用是 <strong>代码复用</strong> ，<strong>操作</strong> 状态和参数；</p></li><li><p><strong>用法</strong> :</p></li><li><p><strong>属性代理 (Props Proxy)</strong> : 返回出一个组件，它基于被包裹组件进行 <strong>功能增强</strong> ；</p><ul><li><strong>默认参数</strong> : 可以为组件包裹一层默认参数；</li></ul><p><code>scala function proxyHoc(Comp) { return class extends React.Component { render() { const newProps = { name: &#39;tayde&#39;, age: 1, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } </code></p><ul><li><strong>提取状态</strong> : 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:</li></ul><p><code>kotlin function withOnChange(Comp) { return class extends React.Component { constructor(props) { super(props) this.state = { name: &#39;&#39;, } } onChangeName = () =&gt; { this.setState({ name: &#39;dongdong&#39;, }) } render() { const newProps = { value: this.state.name, onChange: this.onChangeName, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } </code> 使用姿势如下，这样就能非常快速的将一个 <code>Input</code> 组件转化成受控组件。 <code>dart const NameInput = props =&gt; (&lt;input name=&quot;name&quot; {...props} /&gt;) export default withOnChange(NameInput) </code></p><ul><li><strong>包裹组件</strong> : 可以为被包裹元素进行一层包装，</li></ul><p><code>scala function withMask(Comp) { return class extends React.Component { render() { return ( &lt;div&gt; &lt;Comp {...this.props} /&gt; &lt;div style={{ width: &#39;100%&#39;, height: &#39;100%&#39;, backgroundColor: &#39;rgba(0, 0, 0, .6)&#39;, }} &lt;/div&gt; ) } } } </code></p></li><li><p><strong>反向继承</strong> (Inheritance Inversion): 返回出一个组件， <strong>继承于被包裹组件</strong> ，常用于以下操作:</p><div class="language-scala ext-scala line-numbers-mode"><pre class="language-scala"><code>function IIHoc<span class="token punctuation">(</span>Comp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token keyword">extends</span> Comp <span class="token punctuation">{</span>
        render<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>render<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>渲染劫持</strong> (Render Highjacking)</p><ul><li><strong>条件渲染</strong> : 根据条件，渲染不同的组件</li></ul><div class="language-scala ext-scala line-numbers-mode"><pre class="language-scala"><code>function withLoading<span class="token punctuation">(</span>Comp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token keyword">extends</span> Comp <span class="token punctuation">{</span>
        render<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isLoading<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">&lt;</span>Loading <span class="token operator">/</span><span class="token operator">&gt;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>render<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以直接修改被包裹组件渲染出的 React 元素树</li></ul></li><li><p><strong>操作状态</strong> (Operate State): 可以直接通过 <code>this.state</code> 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</p></li></ul></li><li><p><strong>应用场景</strong> :</p></li><li><p><strong>权限控制</strong> ，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:</p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">async</span> <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> currentRole <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getCurrentUserRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> currentRole <span class="token operator">===</span> <span class="token string">&#39;Admin&#39;</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>您没有权限查看该页面，请联系管理员！<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>性能监控</strong> ，包裹组件的生命周期，进行统一埋点:</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">withTiming</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Comp <span class="token punctuation">{</span>
          <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">super</span><span class="token punctuation">.</span>componentDidMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>WrappedComponent<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 组件渲染时间为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>start<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>代码复用</strong> ，可以将重复的逻辑进行抽象。</p></li><li><p>使用注意:</p><ul><li><ol><li><strong>纯函数</strong> : 增强函数应为纯函数，避免侵入修改元组件；</li></ol></li><li><ol start="2"><li><strong>避免用法污染</strong> : 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；</li></ol></li><li><ol start="3"><li><strong>命名空间</strong> : 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；</li></ol></li><li><ol start="4"><li><strong>引用传递</strong> : 如果需要传递元组件的 refs 引用，可以使用 <code>React.forwardRef</code>；</li></ol></li><li><ol start="5"><li><strong>静态方法</strong> : 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:</li></ol><ul><li>函数导出</li><li>静态方法赋值</li></ul></li><li><ol start="6"><li><strong>重新渲染</strong> : 由于增强函数每次调用是返回一个新组件，因此如果在 Render 中使用增强函数，就会导致每次都重新渲染整个 HOC，而且之前的状态会丢失；</li></ol></li></ul></li></ul><h2 id="_5-redux" tabindex="-1"><a class="header-anchor" href="#_5-redux" aria-hidden="true">#</a> 5. Redux</h2><p>Redux 是一个 <strong>数据管理中心</strong> ，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中，从而也为同构应用提供了更好的数据同步通道。</p><ul><li><strong>核心理念</strong> :</li><li><strong>单一数据源</strong> : 整个应用只有唯一的状态树，也就是所有 state 最终维护在一个根级 Store 中；</li><li><strong>状态只读</strong> : 为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件： <ul><li>Redux Store 中的数据无法被直接修改；</li><li>严格控制修改的执行；</li></ul></li><li><strong>纯函数</strong> : 规定只能通过一个纯函数 (Reducer) 来描述修改；</li><li>大致的数据结构如下所示:</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d09c40cec7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><ul><li><strong>理念实现</strong> :</li><li><strong>Store</strong> : 全局 Store 单例， 每个 Redux 应用下只有一个 store， 它具有以下方法供使用: <ul><li><code>getState</code>: 获取 state；</li><li><code>dispatch</code>: 触发 action, 更新 state；</li><li><code>subscribe</code>: 订阅数据变更，注册监听器；</li></ul></li></ul><div class="language-reasonml ext-reasonml line-numbers-mode"><pre class="language-reasonml"><code>  // 创建
  const store = createStore(Reducer, initStore)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Action</strong> : 它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store <strong>唯一的数据源</strong> ；</li></ul><div class="language-go ext-go line-numbers-mode"><pre class="language-go"><code>  <span class="token comment">// 一个普通的 Action</span>
  <span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span>
  	<span class="token keyword">type</span><span class="token punctuation">:</span> <span class="token char">&#39;ADD_LIST&#39;</span><span class="token punctuation">,</span>
  	item<span class="token punctuation">:</span> &#39;list<span class="token operator">-</span>item<span class="token operator">-</span><span class="token number">1</span>&#39;<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用：</span>
  store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>

  <span class="token comment">// 通常为了便于调用，会有一个 Action 创建函数 (action creater)</span>
  funtion <span class="token function">addList</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">return</span> <span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span>
  		<span class="token keyword">type</span><span class="token punctuation">:</span> <span class="token char">&#39;ADD_LIST&#39;</span><span class="token punctuation">,</span>
  		item<span class="token punctuation">,</span>
  	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 调用就会变成:</span>
  <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">addList</span><span class="token punctuation">(</span>&#39;list<span class="token operator">-</span>item<span class="token operator">-</span><span class="token number">1</span>&#39;<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Reducer</strong> : 用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质；</li></ul><div class="language-pf ext-pf line-numbers-mode"><pre class="language-pf"><code>  // 一个常规的 Reducer
  // @param {state}: 旧数据
  // @param {action}: Action 对象
  // @returns {any}: 新数据
  const initList = []
  function ListReducer(state = initList, action) {
  	switch (action.type) {
  		case &#39;ADD_LIST&#39;:
  			return state.concat([action.item])
  			break
  		defalut:
  			return state
  	}
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong> :</p><ol><li>遵守数据不可变，不要去直接修改 state，而是返回出一个 <strong>新对象</strong> ，可以使用 <code>assign / copy / extend / 解构</code> 等方式创建新对象；</li><li>默认情况下需要 <strong>返回原数据</strong> ，避免数据被清空；</li><li>最好设置 <strong>初始值</strong> ，便于应用的初始化及数据稳定；</li></ol></blockquote><ul><li><strong>进阶</strong> :</li><li><strong>React-Redux</strong> : 结合 React 使用； <ul><li><code>&lt;Provider&gt;</code>: 将 store 通过 context 传入组件中；</li><li><code>connect</code>: 一个高阶组件，可以方便在 React 组件中使用 Redux；</li><li><ol><li>将 <code>store</code>通过 <code>mapStateToProps</code>进行筛选后使用 <code>props</code>注入组件</li></ol></li><li><ol start="2"><li>根据 <code>mapDispatchToProps</code>创建方法，当组件调用时使用 <code>dispatch</code>触发对应的 <code>action</code></li></ol></li></ul></li><li><strong>Reducer 的拆分与重构</strong> : <ul><li>随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 <strong>难以维护</strong> ；</li><li>可以将 reducer 进行拆分，也就是 <strong>函数分解</strong> ，最终再使用 <code>combineReducers()</code>进行重构合并；</li></ul></li><li><strong>异步 Action</strong> : 由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再 <code>dispatch(Action)</code>即可，下面是三种不同的异步实现: <ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux-thunk" title="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener noreferrer">redex-thunk<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-saga%2Fredux-saga" title="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener noreferrer">redux-saga<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-observable%2Fredux-observable" title="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener noreferrer">redux-observable<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></li></ul><h2 id="_6-react-hooks" tabindex="-1"><a class="header-anchor" href="#_6-react-hooks" aria-hidden="true">#</a> 6. React Hooks</h2><p>React 中通常使用 <strong>类定义</strong> 或者 <strong>函数定义</strong> 创建组件:</p><p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p><ul><li><strong>好处</strong> :</li><li>1、 <strong>跨组件复用</strong> : 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li><li>2、 <strong>类定义更为复杂</strong> : <ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li><li>时刻需要关注 <code>this</code>的指向问题；</li><li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul></li><li>3、 <strong>状态与 UI 隔离</strong> : 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li><li><strong>注意</strong> :</li><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li><li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li><li>不能在 <code>useEffect</code>中使用 <code>useState</code>，React 会报错提示；</li><li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li><li><strong>重要钩子</strong> *:</li><li><strong>状态钩子</strong> (<code>useState</code>): 用于定义组件的 State，其到类定义中 <code>this.state</code>的功能；</li></ul><div class="language-pf ext-pf line-numbers-mode"><pre class="language-pf"><code>  // useState 只接受一个参数: 初始状态
  // 返回的是组件名和更改该组件对应的函数
  const [flag, setFlag] = useState(true);
  // 修改状态
  setFlag(false)

  // 上面的代码映射到类定义中:
  this.state = {
  	flag: true
  }
  const flag = this.state.flag
  const setFlag = (bool) =&gt; {
      this.setState({
          flag: bool,
      })
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>生命周期钩子</strong> (<code>useEffect</code>):</p><p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (<code>useEffect</code>)，这里可以看做 <code>componentDidMount</code>、<code>componentDidUpdate</code>和 <code>componentWillUnmount</code>的结合。</p></li><li><p><code>useEffect(callback, [source])</code>接受两个参数</p><ul><li><code>callback</code>: 钩子回调函数；</li><li><code>source</code>: 设置触发条件，仅当 source 发生改变时才会触发；</li><li><code>useEffect</code>钩子在没有传入 <code>[source]</code>参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li></ul></li></ul><div class="language-awk ext-awk line-numbers-mode"><pre class="language-awk"><code>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  	<span class="token regex">//</span> 组件挂载后执行事件绑定
  	console.<span class="token function">log</span><span class="token punctuation">(</span>&#39;on&#39;<span class="token punctuation">)</span>
  	<span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  	<span class="token operator">/</span><span class="token operator">/</span> 组件 update 时会执行事件解绑
  	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  		console.<span class="token function">log</span><span class="token punctuation">(</span>&#39;off&#39;<span class="token punctuation">)</span>
  		<span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>source<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token regex">//</span> 每次 source 发生改变时，执行结果<span class="token punctuation">(</span>以类定义的生命周期，便于大家理解<span class="token punctuation">)</span><span class="token operator">:</span>
  <span class="token regex">//</span> <span class="token operator">--</span><span class="token operator">-</span> DidMount <span class="token operator">--</span><span class="token operator">-</span>
  <span class="token regex">//</span> &#39;on&#39;
  <span class="token regex">//</span> <span class="token operator">--</span><span class="token operator">-</span> DidUpdate <span class="token operator">--</span><span class="token operator">-</span>
  <span class="token regex">//</span> &#39;off&#39;
  <span class="token regex">//</span> &#39;on&#39;
  <span class="token regex">//</span> <span class="token operator">--</span><span class="token operator">-</span> DidUpdate <span class="token operator">--</span><span class="token operator">-</span>
  <span class="token regex">//</span> &#39;off&#39;
  <span class="token regex">//</span> &#39;on&#39;
  <span class="token regex">//</span> <span class="token operator">--</span><span class="token operator">-</span> WillUnmount <span class="token operator">--</span><span class="token operator">-</span>
  <span class="token regex">//</span> &#39;off&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>通过第二个参数，我们便可模拟出几个常用的生命周期:</p><ul><li><code>componentDidMount</code>: 传入 <code>[]</code>时，就只会在初始化时调用一次；</li></ul><div class="language-coffeescript ext-coffeescript line-numbers-mode"><pre class="language-coffeescript"><code>const <span class="token function-variable function">useMount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>componentWillUnmount</code>: 传入 <code>[]</code>，回调中的返回的函数也只会被最终执行一次；</li></ul><div class="language-coffeescript ext-coffeescript line-numbers-mode"><pre class="language-coffeescript"><code>const <span class="token function-variable function">useUnmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>mounted</code>: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li></ul><div class="language-arcade ext-arcade line-numbers-mode"><pre class="language-arcade"><code>const useMounted = () =&gt; {
    const [mounted, setMounted] = useState(false);
    useEffect(() =&gt; {
        !mounted &amp;&amp; setMounted(true);
        return () =&gt; setMounted(false);
    }, []);
    return mounted;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>componentDidUpdate</code>: <code>useEffect</code>每次均会执行，其实就是排除了 DidMount 后即可；</li></ul><div class="language-lisp ext-lisp line-numbers-mode"><pre class="language-lisp"><code>const mounted = useMounted<span class="token punctuation">(</span><span class="token punctuation">)</span>
useEffect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> =&gt; {
    mounted &amp;&amp; fn<span class="token punctuation">(</span><span class="token punctuation">)</span>
}<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>其它内置钩子</strong> :</p></li><li><p><code>useContext</code>: 获取 context 对象</p></li><li><p><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p><ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li><li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li><li>配合 <code>useContext</code>的全局性，可以完成一个轻量级的 Redux；(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fctrlplusb%2Feasy-peasy" title="https://github.com/ctrlplusb/easy-peasy" target="_blank" rel="noopener noreferrer">easy-peasy<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>)</li></ul></li><li><p><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</p></li><li><p><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</p></li><li><p><code>useRef</code>: 获取组件的真实节点；</p></li><li><p><code>useLayoutEffect</code>:</p><ul><li>DOM 更新同步钩子。用法与 <code>useEffect</code>类似，只是区别于执行时间点的不同。</li><li><code>useEffect</code>属于异步执行，并不会等待 DOM 真正渲染后执行，而 <code>useLayoutEffect</code>则会真正渲染后才触发；</li><li>可以获取更新后的 state；</li></ul></li><li><p><strong>自定义钩子</strong> (<code>useXxxxx</code>): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的 <code>useMounted</code>。又例如，我们需要每个页面自定义标题:</p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useTitle</span><span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用:</span>
<span class="token keyword">function</span> <span class="token function">Home</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">&#39;我是首页&#39;</span><span class="token punctuation">;</span>
  <span class="token function">useTitle</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-ssr" tabindex="-1"><a class="header-anchor" href="#_7-ssr" aria-hidden="true">#</a> 7. SSR</h2><p>SSR，俗称 <strong>服务端渲染</strong> (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。</p><ul><li><strong>前后端分离</strong> : 前端与服务端隔离，前端动态获取数据，渲染页面。</li><li><strong>痛点</strong> :</li><li><strong>首屏渲染性能瓶颈</strong> : <ul><li>空白延迟: HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。</li></ul></li><li><strong>SEO 问题</strong> : 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。 <ul><li>虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。</li></ul></li></ul><p>最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独立的开发模式，又要由服务端渲染，因此我们使用 React SSR。</p><ul><li><strong>原理</strong> :</li><li>Node 服务: 让前后端运行同一套代码成为可能。</li><li>Virtual Dom: 让前端代码脱离浏览器运行。</li><li><strong>条件</strong> : Node 中间层、 React / Vue 等框架。 结构大概如下:</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d41797a4d1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><ul><li><strong>开发流程</strong> : (此处以 React + Router + Redux + Koa 为例)</li><li>1、在同个项目中，<strong>搭建</strong> 前后端部分，常规结构: <ul><li>build</li><li>public</li><li>src <ul><li>client</li><li>server</li></ul></li></ul></li><li>2、server 中使用 Koa <strong>路由监听</strong> 页面访问:</li></ul><div class="language-dart ext-dart line-numbers-mode"><pre class="language-dart"><code>  <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token operator">as</span> <span class="token class-name">Router</span> from <span class="token string-literal"><span class="token string">&#39;koa-router&#39;</span></span>

  <span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 如果中间也提供 Api 层</span>
  router<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;/api/home&#39;</span></span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 返回数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;*&#39;</span></span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 返回 HTML</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>3、通过访问 url <strong>匹配</strong> 前端页面路由:</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 前端页面路由</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> pages <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../../client/app&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> matchPath <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react-router-dom&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 react-router 库提供的一个匹配方法</span>
<span class="token keyword">const</span> matchPage <span class="token operator">=</span> <span class="token function">matchPath</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>4、通过页面路由的配置进行 <strong>数据获取</strong> 。通常可以在页面路由中增加 SSR 相关的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:</p><div class="language-scala ext-scala line-numbers-mode"><pre class="language-scala"><code><span class="token keyword">class</span> HomePage <span class="token keyword">extends</span> React<span class="token punctuation">.</span>Component<span class="token punctuation">{</span>
	public static ssrConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
		  cache<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
         fetch<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	  <span class="token comment">// 请求获取数据</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取数据通常有两种情况:</p><ul><li>中间层也使用 <strong>http</strong> 获取数据，则此时 fetch 方法可前后端共享；</li></ul><div class="language-haskell ext-haskell line-numbers-mode"><pre class="language-haskell"><code><span class="token builtin">const</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token hvariable">await</span> <span class="token hvariable">matchPage</span><span class="token punctuation">.</span><span class="token hvariable">ssrConfig</span><span class="token punctuation">.</span><span class="token hvariable">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>中间层并不使用 http，是通过一些 <strong>内部调用</strong> ，例如 Rpc 或 直接读数据库 等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。</li></ul><div class="language-scala ext-scala line-numbers-mode"><pre class="language-scala"><code><span class="token comment">// 页面路由</span>
<span class="token keyword">class</span> HomePage <span class="token keyword">extends</span> React<span class="token punctuation">.</span>Component<span class="token punctuation">{</span>
	public static ssrConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
        fetch<span class="token operator">:</span> <span class="token punctuation">{</span>
        	 url<span class="token operator">:</span> <span class="token string">&#39;/api/home&#39;</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 根据规则匹配出对应的数据获取方法</span>
<span class="token comment">// 这里的规则可以自由，只要能匹配出正确的方法即可</span>
const controller <span class="token operator">=</span> matchController<span class="token punctuation">(</span>ssrConfig<span class="token punctuation">.</span>fetch<span class="token punctuation">.</span>url<span class="token punctuation">)</span>

<span class="token comment">// 获取数据</span>
const data <span class="token operator">=</span> await controller<span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>5、创建 Redux store，并将数据 <code>dispatch</code>到里面:</p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;redux&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 Clinet层 reducer</span>
<span class="token comment">// 必须复用前端层的逻辑，才能保证一致性；</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> reducers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../../client/store&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 创建 store</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>reducers<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取配置好的 Action</span>
<span class="token keyword">const</span> action <span class="token operator">=</span> ssrConfig<span class="token punctuation">.</span>action<span class="token punctuation">;</span>

<span class="token comment">// 存储数据</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">createAction</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>6、注入 Store， 调用 <code>renderToString</code>将 React Virtual Dom 渲染成 <strong>字符串</strong> :</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> ReactDOMServer <span class="token keyword">from</span> <span class="token string">&#39;react-dom/server&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Provider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react-redux&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 获取 Clinet 层根组件</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../../client/app&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> AppString <span class="token operator">=</span> ReactDOMServer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Provider store<span class="token operator">=</span><span class="token punctuation">{</span>store<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>StaticRouter location<span class="token operator">=</span><span class="token punctuation">{</span>ctx<span class="token punctuation">.</span>req<span class="token punctuation">.</span>url<span class="token punctuation">}</span> context<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>StaticRouter<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Provider<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>7、将 AppString 包装成完整的 html 文件格式；</li><li>8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的页面，没有样式没有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成的 <code>asset-manifest.json</code>文件来获取相应的文件路径，并同样注入到 Html 中引用。</li></ul><div class="language-dust ext-dust line-numbers-mode"><pre class="language-dust"><code>  const html = `
  	&lt;!DOCTYPE html&gt;
  	&lt;html lang=&quot;zh&quot;&gt;
  		&lt;head&gt;&lt;/head&gt;
  		&lt;link href=&quot;${cssPath}&quot; rel=&quot;stylesheet&quot; /&gt;
  		&lt;body&gt;
  			&lt;div id=&quot;App&quot;&gt;${AppString}&lt;/div&gt;
  			&lt;script src=&quot;${scriptPath}&quot;&gt;&lt;/script&gt;
  		&lt;/body&gt;
  	&lt;/html&gt;
  `
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>9、进行 <strong>数据脱水</strong> : 为了把服务端获取的数据同步到前端。主要是将数据序列化后，插入到 html 中，返回给前端。</li></ul><div class="language-dust ext-dust line-numbers-mode"><pre class="language-dust"><code>  import serialize from &#39;serialize-javascript&#39;
  // 获取数据
  const initState = store.getState()
  const html = `
  	&lt;!DOCTYPE html&gt;
  	&lt;html lang=&quot;zh&quot;&gt;
  		&lt;head&gt;&lt;/head&gt;
  		&lt;body&gt;
  			&lt;div id=&quot;App&quot;&gt;&lt;/div&gt;
  			&lt;script type=&quot;application/json&quot; id=&quot;SSR_HYDRATED_DATA&quot;&gt;${serialize(initState)}&lt;/script&gt;
  		&lt;/body&gt;
  	&lt;/html&gt;
  `

  ctx.status = 200
  ctx.body = html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>Tips</strong> :</p><p>这里比较特别的有两点:</p><ol><li>使用了 <code>serialize-javascript</code>序列化 store， 替代了 <code>JSON.stringify</code>，保证数据的安全性，避免代码注入和 XSS 攻击；</li><li>使用 json 进行传输，可以获得更快的加载速度；</li></ol></blockquote><ul><li>10、Client 层  <strong>数据吸水</strong> : 初始化 store 时，以脱水后的数据为初始化数据，同步创建 store。</li></ul><div class="language-pf ext-pf line-numbers-mode"><pre class="language-pf"><code>  const hydratedEl = document.getElementById(&#39;SSR_HYDRATED_DATA&#39;)
  const hydrateData = JSON.parse(hydratedEl.textContent)

  // 使用初始 state 创建 Redux store
  const store = createStore(reducer, hydrateData)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-函数式编程" tabindex="-1"><a class="header-anchor" href="#_8-函数式编程" aria-hidden="true">#</a> 8. 函数式编程</h2><p>函数式编程是一种 <strong>编程范式</strong> ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 <strong>更简洁、可预测、高复用、易测试</strong> 。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。</p><ul><li><p><strong>常见的编程范式</strong> :</p></li><li><p>命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；</p></li><li><p>事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；</p></li><li><p>面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；</p></li><li><p>函数式编程</p><ul><li>换成一种更高端的说法，面向数学编程。怕不怕~🥴</li></ul></li><li><p><strong>函数式编程的理念</strong> :</p></li><li><p><strong>纯函数</strong> (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</p><ul><li><p><strong>优势</strong> :</p></li><li><p>完全独立，与外部解耦；</p></li><li><p>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</p></li><li><p>可测试性极强；</p><ul><li><strong>条件</strong> :</li></ul></li><li><p>不修改参数；</p></li><li><p>不依赖、不修改任何函数外部的数据；</p></li><li><p>完全可控，参数一样，返回值一定一样: 例如函数不能包含 <code>new Date()</code>或者 <code>Math.rando()</code>等这种不可控因素；</p></li><li><p>引用透明；</p><ul><li>我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如 <code>split / join / map</code>；</li></ul></li></ul></li><li><p><strong>函数复合</strong> : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；</p><ul><li><p><strong>扁平化嵌套</strong> : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:</p></li><li><p><code>f(g(k(x)))</code>: 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；</p></li><li><p>理想的做法: <code>xxx(f, g, k)(x)</code></p><ul><li><strong>结果传递</strong> : 如果想实现上面的方式，那也就是 <code>xxx</code>函数要实现的便是: 执行结果在各个函数之间的执行传递；</li></ul></li><li><p>这时我们就能想到一个原生提供的数组方法: <code>reduce</code>，它可以按数组的顺序依次执行，传递执行结果；</p></li><li><p>所以我们就能够实现一个方法 <code>pipe</code>，用于函数组合:</p></li></ul><div class="language-arcade ext-arcade line-numbers-mode"><pre class="language-arcade"><code>// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) =&gt; p =&gt; fs.reduce((v, f) =&gt; f(v), p)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>*使用</strong> : 实现一个 驼峰命名 转 中划线命名 的功能:</p><div class="language-processing ext-processing line-numbers-mode"><pre class="language-processing"><code><span class="token comment">// &#39;Guo DongDong&#39; --&gt; &#39;guo-dongdong&#39;</span>
<span class="token comment">// 函数组合式写法</span>
const toLowerCase <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">&gt;</span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
const join <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>
const split <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>splitOn<span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>splitOn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const toSlug <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>
	toLowerCase<span class="token punctuation">,</span>
	<span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	encodeURIComponent<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">&#39;Guo DongDong&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>*好处</strong> : _ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率； _ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等； _ 可复用性强，任何一个函数单元都可被任意复用和组合； _ 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:</p><div class="language-arcade ext-arcade line-numbers-mode"><pre class="language-arcade"><code>  const log = curry((label, x) =&gt; {
  	console.log(`${ label }: ${ x }`);
  	return x;
  });

const toSlug = pipe(
  	toLowerCase,
  	log(&#39;toLowerCase output&#39;),
  	split(&#39; &#39;),
  	log(&#39;split output&#39;),
  	join(&#39;_&#39;),
  	log(&#39;join output&#39;),
  	encodeURIComponent,
  );
  ```

&gt;
&gt; Tips:
&gt;
&gt;
&gt; 一些工具纯函数可直接引用`lodash/fp`，例如 `curry/map/split`等，并不需要像我们上面这样自己实现；
&gt;
&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>数据不可变性</strong> (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:</p><ul><li><strong>倡导</strong> : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；</li><li><strong>目的</strong> : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；</li><li>并不等同于 <code>const</code>。使用 <code>const</code>创建一个对象后，它的属性仍然可以被修改；</li><li>更类似于 <code>Object.freeze</code>: 冻结对象，但 <code>freeze</code>仍无法保证深层的属性不被串改；</li><li><code>immutable.js</code>: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；</li><li><code>trie</code>数据结构: <ul><li>一种数据结构，能有效地深度冻结对象，保证其不可变；</li><li><strong>结构共享</strong> : 可以共用不可变对象的内存引用地址，减少内存占用，提高数据操作性能；</li></ul></li></ul></li><li><p>避免不同函数之间的 <strong>状态共享</strong> ，数据的传递使用复制或全新对象，遵守数据不可变原则；</p></li><li><p>避免从函数内部 <strong>改变外部状态</strong> ，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；</p></li><li><p>避免在单元函数内部执行一些 <strong>副作用</strong> ，应该将这些操作抽离成更独立的工具单元；</p><ul><li>日志输出</li><li>读写文件</li><li>网络请求</li><li>调用外部进程</li><li>调用有副作用的函数</li></ul></li><li><p><strong>高阶函数</strong> : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:</p></li><li><p>将逻辑行为进行 <strong>隔离抽象</strong> ，便于快速复用，如处理数据，兼容性等；</p></li><li><p><strong>函数组合</strong> ，将一系列单元函数列表组合成功能更强大的函数；</p></li><li><p><strong>函数增强</strong> ，快速地拓展函数功能，</p></li><li><p><strong>函数式编程的好处</strong> :</p></li><li><p>函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；</p></li><li><p>不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；</p></li><li><p>追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；</p></li><li><p>更易于做单元测试。</p></li><li><p><strong>总结</strong> :</p></li><li><p>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；</p></li><li><p>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</p></li></ul><blockquote><p>Tips:</p><p>其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些个人理解而已。博主也是初级小菜鸟，停留在表面而已，只求对大家能有所帮助，轻喷 🤣；</p><p>我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 <strong>优劣势</strong> 。</p><p>理解和学习它们的理念与优势，合理地 <strong>设计融合</strong> ，将优秀的软件编程思想用于提升我们应用；</p><p>所有设计思想，最终的目标一定是使我们的应用更加 <strong>解耦颗粒化、易拓展、易测试、高复用，开发更为高效和安全</strong> ；</p><p>有一些库能让大家很快地接触和运用函数思想: <code>Underscore.js</code> / <code>Lodash/fp</code> / <code>Rxjs</code> 等。</p></blockquote><p>作者：郭东东 链接：https://juejin.cn/post/6844903801153945608 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">最近一次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1003217877@qq.com">leouncle</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/frontHandbook/interview/vue3.html" class="" aria-label="/interview/vue3.md"><!--[--><!--]--> /interview/vue3.md <!--[--><!--]--></a></span><span class="next"><a href="/frontHandbook/interview/http.html" class="" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/frontHandbook/assets/app.1d2f7275.js" defer></script>
  </body>
</html>
